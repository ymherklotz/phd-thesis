@Comment{
ebib-main-file: /Users/ymherklotz/Dropbox/bibliography/references.bib
}


@Misc{absint19_compc,
	year = {2019},
	title = {{CompCert} release 19.10},
	author = {AbsInt},
	url = {https://www.absint.com/releasenotes/compcert/19.10/}
}

@Misc{absint22_compc,
	url = {https://www.absint.com/releasenotes/compcert/22.10/},
	year = {2022},
	title = {{CompCert} release 22.10},
	author = {AbsInt}
}

@inproceedings{allen83_conver_contr_depen_data_depen,
	abstract = {Program analysis methods, especially those which support automatic vectorization, are based on the concept of interstatement dependence where a dependence holds between two statements when one of the statements computes values needed by the other. Powerful program transformation systems that convert sequential programs to a form more suitable for vector or parallel machines have been developed using this concept [AllK 82, KKLW 80].The dependence analysis in these systems is based on data dependence. In the presence of complex control flow, data dependence is not sufficient to transform programs because of the introduction of control dependences. A control dependence exists between two statements when the execution of one statement can prevent the execution of the other. Control dependences do not fit conveniently into dependence-based program translators.One solution is to convert all control dependences to data dependences by eliminating goto statements and introducing logical variables to control the execution of statements in the program. In this scheme, action statements are converted to IF statements. The variables in the conditional expression of an IF statement can be viewed as inputs to the statement being controlled. The result is that control dependences between statements become explicit data dependences expressed through the definitions and uses of the controlling logical variables.This paper presents a method for systematically converting control dependences to data dependences in this fashion. The algorithms presented here have been implemented in PFC, an experimental vectorizer written at Rice University.},
	author = {Allen, J. R. and Kennedy, Ken and Porterfield, Carrie and Warren, Joe},
	location = {Austin, Texas},
	publisher = {Association for Computing Machinery},
	booktitle = {Proceedings of the 10th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
	doi = {10.1145/567067.567085},
	isbn = {0897910907},
	keywords = {if-conversion},
	pages = {177--189},
	series = {POPL '83},
	title = {Conversion of Control Dependence to Data Dependence},
	year = {1983}
}

@misc{amd23_vitis_forum,
	author = {AMD},
	title = {Vitis Forums},
	url = {https://bit.ly/vitisifc},
	urldate = {2023-06-02},
	year = {2023},
	note = {Relevant quote from AMD: ``If-Conversion aims to convert a sequence of blocks into a single block for better optimization result.''}
}

@misc{googleXLS,
author = {Google},
title = {{XLS: Accelerated HW Synthesis}},
url = {https://github.com/google/xls/blob/dde7095ff1050b09c37cb44d1977bff1af8de050/xls/scheduling/mutual_exclusion_pass.h#L112},
urldate = {2023-11-14},
year = {2023},
note = {The XLS scheduler refers to using an SMT solver to merge mutually exclusive nodes},
}

@misc{amd23_vitis_high_synth,
	author = {AMD},
	title = {Vitis High-level Synthesis},
	url = {https://bit.ly/41R0204},
	urldate = {2023-05-21},
	year = 2023
}

@book{baker19_princ,
	abstract = {An updated edition of the text that explores the core topics in scheduling theory The second edition of Principles of Sequencing and Scheduling has been revised and updated to provide comprehensive coverage of sequencing and scheduling topics as well as emerging developments in the field. The text offers balanced coverage of deterministic models and stochastic models and includes new developments in safe scheduling and project scheduling, including coverage of project analytics. These new topics help bridge the gap between classical scheduling and actual practice. The authors—noted experts in the field—present a coherent and detailed introduction to the basic models, problems, and methods of scheduling theory. This book offers an introduction and overview of sequencing and scheduling and covers such topics as single-machine and multi-machine models, deterministic and stochastic problem formulations, optimization and heuristic solution approaches, and generic and specialized software methods. This new edition adds coverage on topics of recent interest in shop scheduling and project scheduling. This important resource: Offers comprehensive coverage of deterministic models as well as recent approaches and developments for stochastic models Emphasizes the application of generic optimization software to basic sequencing problems and the use of spreadsheet-based optimization methods Includes updated coverage on safe scheduling, lognormal modeling, and job selection Provides basic coverage of robust scheduling as contrasted with safe scheduling Adds a new chapter on project analytics, which supports the PERT21 framework for project scheduling in a stochastic environment. Extends the coverage of PERT 21 to include hierarchical scheduling Provides end-of-chapter references and access to advanced Research Notes, to aid readers in the further exploration of advanced topics Written for upper-undergraduate and graduate level courses covering such topics as scheduling theory and applications, project scheduling, and operations scheduling, the second edition of Principles of Sequencing and Scheduling is a resource that covers scheduling techniques and contains the most current research and emerging topics.},
	author = {Baker, Kenneth R.},
	address = {Hoboken, NJ},
	booktitle = {Principles of sequencing and scheduling},
	edition = {Second edition.},
	isbn = {1-119-26259-3},
	keywords = {scheduling, list scheduling},
	language = {eng},
	publisher = {Wiley},
	series = {Wiley series in operations research and management science},
	title = {Principles of sequencing and scheduling },
	year = {2019}
}

@inproceedings{ball93_branc_predic_free,
	keywords = {if-conversion},
	author = {Ball, Thomas and Larus, James R.},
	title = {Branch Prediction for Free},
	year = {1993},
	isbn = {0897915984},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/155090.155119},
	abstract = {Many compilers rely on branch prediction to improve program performance by identifying frequently executed regions and by aiding in scheduling instructions.Profile-based predictors require a time-consuming and inconvenient compile-profile-compile cycle in order to make predictions. We present a program-based branch predictor that performs well for a large and diverse set of programs written in C and Fortran. In addition to using natural loop analysis to predict branches that control the iteration of loops, we focus on heuristics for predicting non-loop branches, which dominate the dynamic branch count of many programs. The heuristics are simple and require little program analysis, yet they are effective in terms of coverage and miss rate. Although program-based prediction does not equal the accuracy of profile-based prediction, we believe it reaches a sufficiently high level to be useful. Additional type and semantic information available to a compiler would enhance our heuristics.},
	booktitle = {Proceedings of the ACM SIGPLAN 1993 Conference on Programming Language Design and Implementation},
	pages = {300–313},
	numpages = {14},
	location = {Albuquerque, New Mexico, USA},
	series = {PLDI '93}
}

@article{barthe14_formal_verif_ssa_based_middl_end_compc,
	abstract = {CompCert is a formally verified compiler that generates compact and efficient code for a large subset of the C language. However, CompCert foregoes using SSA, an intermediate representation employed by many compilers that enables writing simpler, faster optimizers. In fact, it has remained an open problem to verify formally an SSA-based compiler. We report on a formally verified, SSA-based middle-end for CompCert. In addition to providing a formally verified SSA-based middle-end, we address two problems raised by Leroy in [2009]: giving an intuitive formal semantics to SSA, and leveraging its global properties to reason locally about program optimizations.},
	author = {Barthe, Gilles and Demange, Delphine and Pichardie, David},
	location = {New York, NY, USA},
	publisher = {Association for Computing Machinery},
	url = {https://doi.org/10.1145/2579080},
	doi = {10.1145/2579080},
	issn = {0164-0925},
	journaltitle = {ACM Trans. Program. Lang. Syst.},
	keywords = {CompCertSSA,CompCert,SSA,coq,verification,compiler optimisation},
	month = mar,
	number = {1},
	title = {Formal Verification of an SSA-Based Middle-End for CompCert},
	volume = {36},
	year = {2014}
}

@Misc{berkelaar10,
	year = {2010},
	title = {\textbf{lp\_solve} v5.5},
	author = {Berkelaar, Michel},
	url = {https://lpsolve.sourceforge.net/5.5/}
}

@inproceedings{budiu02_compil_applic_specif_hardw,
	author = {Mihai Budiu and Seth Copen Goldstein},
	editor = {Manfred Glesner and
                  Peter Zipf and
                  Michel Renovell},
	title = {Compiling Application-Specific Hardware},
	booktitle = {Field-Programmable Logic and Applications, Reconfigurable Computing
                  Is Going Mainstream, 12th International Conference, {FPL} 2002, Montpellier,
                  France, September 2-4, 2002, Proceedings},
	series = {Lecture Notes in Computer Science},
	volume = {2438},
	pages = {853--863},
	publisher = {Springer},
	year = {2002},
	doi = {10.1007/3-540-46117-5\_88},
	timestamp = {Tue, 14 May 2019 10:00:48 +0200},
	biburl = {https://dblp.org/rec/conf/fpl/BudiuG02.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{callahan98_instr_level_paral_recon_comput,
	author = {Timothy J. Callahan and John Wawrzynek},
	editor = {Reiner W. Hartenstein and
                  Andres Keevallik},
	title = {Instruction-Level Parallelism for Reconfigurable Computing},
	booktitle = {Field-Programmable Logic and Applications, From FPGAs to Computing
                  Paradigm, 8th International Workshop, FPL'98, Tallinn, Estonia, August
                  31 - September 3, 1998, Proceedings},
	series = {Lecture Notes in Computer Science},
	volume = {1482},
	pages = {248--257},
	publisher = {Springer},
	year = {1998},
	doi = {10.1007/BFb0055252},
	timestamp = {Tue, 14 May 2019 10:00:48 +0200},
	biburl = {https://dblp.org/rec/conf/fpl/CallahanW98.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{canis11_legup,
	abstract = {In this paper, we introduce a new open source high-level synthesis tool called LegUp that allows software techniques to be used for hardware design. LegUp accepts a standard C program as input and automatically compiles the program to a hybrid architecture containing an FPGA-based MIPS soft processor and custom hardware accelerators that communicate through a standard bus interface. Results show that the tool produces hardware solutions of comparable quality to a commercial high-level synthesis tool.},
	author = {Canis, Andrew and Choi, Jongsok and Aldham, Mark and Zhang, Victor and Kammoona, Ahmed and Anderson, Jason H. and Brown, Stephen and Czajkowski, Tomasz},
	location = {Monterey, CA, USA},
	publisher = {Association for Computing Machinery},
	booktitle = {Proceedings of the 19th ACM/SIGDA International Symposium on Field Programmable Gate Arrays},
	doi = {10.1145/1950413.1950423},
	isbn = {9781450305549},
	keywords = {fpgas,hardware/software co-design,field-programmable gate arrays,high-level synthesis},
	pages = {33--36},
	series = {FPGA '11},
	title = {LegUp: High-Level Synthesis for FPGA-Based Processor/Accelerator Systems},
	year = {2011}
}

@PhdThesis{canis15_legup,
	author = {Canis, Andrew},
	keywords = {high-level synthesis,hardware/software co-simulation,FPGA},
	title = {Legup: open-source high-level synthesis research framework},
	type = {phdthesis},
	year = {2015}
}

@article{chang91_using_profil_infor_assis_class_code_optim,
	author = {Pohua P. Chang and
                  Scott A. Mahlke and
                  Wen{-}mei W. Hwu},
	title = {Using Profile Information to Assist Classic Code Optimizations},
	journal = {Softw. Pract. Exp.},
	volume = {21},
	number = {12},
	pages = {1301--1321},
	year = {1991},
	url = {https://doi.org/10.1002/spe.4380211204},
	doi = {10.1002/spe.4380211204},
	timestamp = {Thu, 09 Apr 2020 17:14:34 +0200},
	biburl = {https://dblp.org/rec/journals/spe/ChangMH91.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{cong06_sdc,
	abstract = {Scheduling plays a central role in the behavioral synthesis process, which automatically compiles high-level specifications into optimized hardware implementations. However, most of the existing behavior-level scheduling heuristics either have a limited efficiency in a specific class of applications or lack general support of various design constraints. In this paper we describe a new scheduler that converts a rich set of scheduling constraints into a system of difference constraints (SDC) and performs a variety of powerful optimizations under a unified mathematical programming framework. In particular, we show that our SDC-based scheduling algorithm can efficiently support resource constraints, frequency constraints, latency constraints, and relative timing constraints, and effectively optimize longest path latency, expected overall latency, and the slack distribution. Experiments demonstrate that our proposed technique provides efficient solutions for a broader range of applications with higher quality of results (in terms of system performance) when compared to the state-of-the-art scheduling heuristics},
	author = {Cong, Jason and Zhang, Zhiru},
	booktitle = {2006 43rd ACM/IEEE Design Automation Conference},
	doi = {10.1145/1146909.1147025},
	issn = {0738-100X},
	keywords = {high-level synthesis,static scheduling},
	month = jul,
	pages = {433--438},
	title = {An efficient and versatile scheduling algorithm based on SDC formulation},
	year = {2006}
}

@phdthesis{ellis85_bulld,
	title = {Bulldog: A compiler for {VLIW} architectures},
	author = {Ellis, John R},
	year = {1985},
	school = {Yale University}
}

@article{fisher81_trace_sched,
	author = {Fisher, Joseph A.},
	doi = {10.1109/TC.1981.1675827},
	journaltitle = {IEEE Transactions on Computers},
	keywords = {static scheduling,trace scheduling},
	number = {7},
	pages = {478--490},
	title = {Trace Scheduling: A Technique for Global Microcode Compaction},
	volume = {C-30},
	year = {1981}
}

@inproceedings{herklotz21_empir_study_reliab_high_level_synth_tools,
	author = {Herklotz, Yann and Du, Zewei and Ramanathan, Nadesh and Wickerson, John},
	booktitle = {2021 IEEE 29th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM)},
	doi = {10.1109/FCCM51124.2021.00034},
	pages = {219--223},
	title = {An Empirical Study of the Reliability of High-Level Synthesis Tools},
	year = {2021}
}

@article{herklotz21_formal_verif_high_level_synth,
	abstract = {High-level synthesis (HLS), which refers to the automatic compilation of software into hardware, is rapidly gaining popularity. In a world increasingly reliant on application-specific hardware accelerators, HLS promises hardware designs of comparable performance and energy efficiency to those coded by hand in a hardware description language such as Verilog, while maintaining the convenience and the rich ecosystem of software development. However, current HLS tools cannot always guarantee that the hardware designs they produce are equivalent to the software they were given, thus undermining any reasoning conducted at the software level. Furthermore, there is mounting evidence that existing HLS tools are quite unreliable, sometimes generating wrong hardware or crashing when given valid inputs. To address this problem, we present the first HLS tool that is mechanically verified to preserve the behaviour of its input software. Our tool, called Vericert, extends the CompCert verified C compiler with a new hardware-oriented intermediate language and a Verilog back end, and has been proven correct in Coq. Vericert supports most C constructs, including all integer operations, function calls, local arrays, structs, unions, and general control-flow statements. An evaluation on the PolyBench/C benchmark suite indicates that Vericert generates hardware that is around an order of magnitude slower (only around 2\texttimes{} slower in the absence of division) and about the same size as hardware generated by an existing, optimising (but unverified) HLS tool.},
	author = {Herklotz, Yann and Pollard, James D. and Ramanathan, Nadesh and Wickerson, John},
	location = {New York, NY, USA},
	publisher = {Association for Computing Machinery},
	doi = {10.1145/3485494},
	journaltitle = {Proc. ACM Program. Lang.},
	keywords = {high-level synthesis,Coq,Verilog,CompCert,C},
	month = oct,
	number = {OOPSLA},
	title = {Formal Verification of High-Level Synthesis},
	volume = {5},
	year = {2021}
}

@inbook{hwu93_super,
	abstract = {A compiler for VLIW and superscalar processors must expose sufficient instruction-level parallelism (ILP) to effectively utilize the parallel hardware. However, ILP within basic blocks is extremely limited for control-intensive programs. We have developed a set of techniques for exploiting ILP across basic block boundaries. These techniques are based on a novel structure called the superblock. The superblock enables the optimizer and scheduler to extract more ILP along the important execution paths by systematically removing constraints due to the unimportant paths. Superblock optimization and scheduling have been implemented in the IMPACT-I compiler. This implementation gives us a unique opportunity to fully understand the issues involved in incorporating these techniques into a real compiler. Superblock optimizations and scheduling are shown to be useful while taking into account a variety of architectural features.},
	author = {Hwu, Wen-Mei W. and Mahlke, Scott A. and Chen, William Y. and Chang, Pohua P. and Warter, Nancy J. and Bringmann, Roger A. and Ouellette, Roland G. and Hank, Richard E. and Kiyohara, Tokuzo and Haab, Grant E. and Holm, John G. and Lavery, Daniel M.},
	editor = {Rau, B. R. and Fisher, J. A.},
	location = {Boston, MA},
	publisher = {Springer US},
	booktitle = {Instruction-Level Parallelism: A Special Issue of The Journal of Supercomputing},
	doi = {10.1007/978-1-4615-3200-2_7},
	isbn = {978-1-4615-3200-2},
	keywords = {superblock scheduling,trace scheduling,static scheduling},
	pages = {229--248},
	title = {The Superblock: An Effective Technique for VLIW and Superscalar Compilation},
	year = {1993}
}

@misc{intel20_high_synth_compil,
	author = {Intel},
	url = {https://intel.ly/2UDiWr5},
	title = {High-level Synthesis Compiler},
	urldate = {2023-06-23},
	year = {2023}
}

@book{jones86_system_vdm,
	author = {Jones, Cliff B.},
	title = {Systematic software development using {VDM}},
	series = {Prentice Hall International Series in Computer Science},
	publisher = {Prentice Hall},
	year = {1986},
	isbn = {978-0-13-880725-2},
	timestamp = {Thu, 14 Apr 2011 14:43:25 +0200},
	biburl = {https://dblp.org/rec/books/daglib/0068091.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{leroy09_formal_verif_compil_back_end,
	abstract = {This article describes the development and formal verification (proof of semantic preservation) of a compiler back-end from Cminor (a simple imperative intermediate language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its soundness. Such a verified compiler is useful in the context of formal methods applied to the certification of critical software: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
	author = {Leroy, Xavier},
	doi = {10.1007/s10817-009-9155-4},
	issn = {1573-0670},
	journaltitle = {Journal of Automated Reasoning},
	number = {4},
	pages = {363},
	title = {A Formally Verified Compiler Back-End},
	volume = {43},
	year = {2009}
}

@article{mahlke92_effec_compil_suppor_predic_execut_using_hyper,
	author = {Mahlke, Scott A. and Lin, David C. and Chen, William Y. and Hank, Richard E. and Bringmann, Roger A.},
	location = {New York, NY, USA},
	publisher = {Association for Computing Machinery},
	doi = {10.1145/144965.144998},
	issn = {1050-916X},
	journaltitle = {SIGMICRO Newsl.},
	keywords = {speculative execution,static scheduling,hyperblocks},
	month = 12,
	number = {1-2},
	pages = {45--54},
	title = {Effective Compiler Support for Predicated Execution Using the Hyperblock},
	volume = {23},
	year = {1992}
}

@article{pangrle87_desig_tools_intel_silic_compil,
	author = {Barry M. Pangrle and
                  Daniel D. Gajski},
	title = {Design Tools for Intelligent Silicon Compilation},
	journal = {{IEEE} Trans. Comput. Aided Des. Integr. Circuits Syst.},
	volume = {6},
	number = {6},
	pages = {1098--1112},
	year = {1987},
	url = {https://doi.org/10.1109/TCAD.1987.1270350},
	doi = {10.1109/TCAD.1987.1270350},
	timestamp = {Thu, 24 Sep 2020 11:28:40 +0200},
	biburl = {https://dblp.org/rec/journals/tcad/PangrleG87.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}



@misc{pouchet20_polyb_c,
	author = {Pouchet, Louis-No\"el},
	title = {PolyBench/C: the Polyhedral Benchmark suite},
	url = {http://web.cse.ohio-state.edu/~pouchet.2/software/polybench/},
	year = {2020}
}

@inproceedings{sen15_multis,
	author = {Sen, Koushik and Necula, George and Gong, Liang and Choi, Wontae},
	title = {MultiSE: Multi-Path Symbolic Execution Using Value Summaries},
	year = {2015},
	isbn = {9781450336758},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2786805.2786830},
	doi = {10.1145/2786805.2786830},
	abstract = {Dynamic symbolic execution (DSE) has been proposed to effectively generate test inputs for real-world programs. Unfortunately, DSE techniques do not scale well for large realistic programs, because often the number of feasible execution paths of a program increases exponentially with the increase in the length of an execution path. In this paper, we propose MultiSE, a new technique for merging states incrementally during symbolic execution, without using auxiliary variables. The key idea of MultiSE is based on an alternative representation of the state, where we map each variable, including the program counter, to a set of guarded symbolic expressions called a value summary. MultiSE has several advantages over conventional DSE and conventional state merging techniques: value summaries enable sharing of symbolic expressions and path constraints along multiple paths and thus avoid redundant execution. MultiSE does not introduce auxiliary symbolic variables, which enables it to 1) make progress even when merging values not supported by the constraint solver, 2) avoid expensive constraint solver calls when resolving function calls and jumps, and 3) carry out most operations concretely. Moreover, MultiSE updates value summaries incrementally at every assignment instruction, which makes it unnecessary to identify the join points and to keep track of variables to merge at join points. We have implemented MultiSE for JavaScript programs in a publicly available open-source tool. Our evaluation of MultiSE on several programs shows that 1) value summaries are an eective technique to take advantage of the sharing of value along multiple execution path, that 2) MultiSE can run significantly faster than traditional dynamic symbolic execution and, 3) MultiSE saves a substantial number of state merges compared to conventional state-merging techniques.},
	booktitle = {Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering},
	pages = {842–853},
	numpages = {12},
	keywords = {symbolic execution, value summaries, predicated execution, hyperblocks},
	location = {Bergamo, Italy},
	series = {ESEC/FSE 2015}
}

@article{six20_certif_effic_instr_sched,
	abstract = {CompCert is a moderately optimizing C compiler with a formal, machine-checked, proof of correctness: after successful compilation, the assembly code has a behavior faithful to the source code. Previously, it only supported target instruction sets with sequential semantics, and did not attempt reordering instructions for optimization. We present here a CompCert backend for a VLIW core (i.e. with explicit parallelism at the instruction level), the first CompCert backend providing scalable and efficient instruction scheduling. Furthermore, its highly modular implementation can be easily adapted to other VLIW or non-VLIW pipelined processors.},
	author = {Six, Cyril and Boulmé, Sylvain and Monniaux, David},
	location = {New York, NY, USA},
	publisher = {Association for Computing Machinery},
	doi = {10.1145/3428197},
	journaltitle = {Proc. ACM Program. Lang.},
	keywords = {coq,translation validation,scheduling,static scheduling,verification,VLIW,operational semantics},
	month = nov,
	number = {OOPSLA},
	title = {Certified and Efficient Instruction Scheduling: Application to Interlocked VLIW Processors},
	volume = {4},
	year = {2020}
}

@inproceedings{six22_formal_verif_super_sched,
	abstract = {On in-order processors, without dynamic instruction scheduling, program running times may be significantly reduced by compile-time instruction scheduling. We present here the first effective certified instruction scheduler that operates over superblocks (it may move instructions across branches), along with its performance evaluation. It is integrated within the CompCert C compiler, providing a complete machine-checked proof of semantic preservation from C to assembly. Our optimizer composes several passes designed by translation validation: program transformations are proposed by untrusted oracles, which are then validated by certified and scalable checkers. Our main checker is an architecture-independent simulation-test over superblocks modulo register liveness, which relies on hash-consed symbolic execution.},
	author = {Six, Cyril and Gourdin, Léo and Boulmé, Sylvain and Monniaux, David and Fasse, Justus and Nardino, Nicolas},
	location = {Philadelphia, PA, USA},
	publisher = {Association for Computing Machinery},
	booktitle = {Proceedings of the 11th ACM SIGPLAN International Conference on Certified Programs and Proofs},
	doi = {10.1145/3497775.3503679},
	isbn = {9781450391825},
	keywords = {Symbolic execution,Instruction-level parallelism,Translation validation,the COQ proof assistant},
	pages = {40--54},
	series = {CPP 2022},
	title = {Formally Verified Superblock Scheduling},
	year = {2022}
}

@inproceedings{tristan08_formal_verif_trans_valid,
	author = {Tristan, Jean-Baptiste and Leroy, Xavier},
	location = {San Francisco, California, USA},
	publisher = {Association for Computing Machinery},
	booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
	doi = {10.1145/1328438.1328444},
	isbn = {9781595936899},
	keywords = {coq,translation validation,CompCert,static scheduling},
	pages = {17--27},
	series = {POPL '08},
	title = {Formal Verification of Translation Validators: A Case Study on Instruction Scheduling Optimizations},
	year = {2008}
}

@inproceedings{zhang13_sdc,
	abstract = {Modulo scheduling is a popular technique to enable pipelined execution of successive loop iterations for performance improvement. While a variety of modulo scheduling algorithms exist for software pipelining, they are not amenable to many complex design constraints and optimization goals that arise in the hardware synthesis context. In this paper we describe a modulo scheduling framework based on the formulation of system of difference constraints (SDC). Our framework can systematically model a rich set of performance constraints that are specific to the hardware design. The scheduler also exploits the unique mathematical properties of SDC to carry out efficient global optimization and fast incremental update on the constraint system to minimize the resource usage of the synthesized pipeline. Experiments demonstrate that our proposed technique provides efficient solutions for a set of real-life applications and compares favorably against a widely used lifetime-sensitive modulo scheduling algorithm.},
	author = {Zhang, Zhiru and Liu, Bin},
	booktitle = {2013 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)},
	doi = {10.1109/ICCAD.2013.6691121},
	issn = {1558-2434},
	keywords = {high level synthesis;pipeline processing;scheduling;SDC-based modulo scheduling;pipeline synthesis;hardware design;mathematical properties;global optimization;incremental update;Schedules;Pipeline processing;Registers;Optimal scheduling;Scheduling algorithms;Timing},
	month = nov,
	pages = {211--218},
	title = {SDC-based modulo scheduling for pipeline synthesis},
	year = {2013}
}


@phdthesis{hopwoodthesis,
author = {Hopwood, Gregory Littell},
title = {Decompilation},
year = {1978},
publisher = {University of California, Irvine},
note = {AAI7811860}
}

@article{chouksey20_verif_sched_condit_behav_high_level_synth,
  author          = {R. {Chouksey} and C. {Karfa}},
  title           = {Verification of Scheduling of Conditional Behaviors in
                  High-Level Synthesis},
  journal         = {IEEE Transactions on Very Large Scale Integration (VLSI)
                  Systems},
  volume          = {},
  number          = {},
  pages           = {1-14},
  year            = {2020},
  doi             = {10.1109/TVLSI.2020.2978242},
  url             = {https://doi.org/10.1109/TVLSI.2020.2978242},
  ISSN            = {1557-9999},
  month           = {},
}

@inproceedings{karfa06_formal_verif_method_sched_high_synth,
  author =       {Karfa, C and Mandal, C and Sarkar, D and Pentakota, S R. and
                  Reade, Chris},
  title =        {A Formal Verification Method of Scheduling in High-level
                  Synthesis},
  booktitle =    {Proceedings of the 7th International Symposium on Quality
                  Electronic Design},
  year =         2006,
  pages =        {71--78},
  doi =          {10.1109/ISQED.2006.10},
  acmid =        1126731,
  address =      {Washington, DC, USA},
  isbn =         {0-7695-2523-7},
  numpages =     8,
  publisher =    {IEEE Computer Society},
  series =       {ISQED '06},
}

@inproceedings{kim04_autom_fsmd,
  author = { {Youngsik Kim} and S. {Kopuri} and N. {Mansouri}},
  title = {Automated formal verification of scheduling process using
                  finite state machines with datapath (FSMD)},
  booktitle = {International Symposium on Signals, Circuits and
                  Systems. Proceedings, SCS 2003. (Cat. No.03EX720)},
  year = 2004,
  pages = {110-115},
  doi = {10.1109/ISQED.2004.1283659},
  month = {3}
}

@misc{mentor20_catap_high_level_synth,
  author          = {Siemens},
  title           = {Catapult High-Level Synthesis},
  url             = {https://eda.sw.siemens.com/en-US/ic/catapult-high-level-synthesis/hls/c-cplus/},
  urldate         = {2023-11-14},
  year            = 2021,
}

@misc{bambu_ifc,
author = {Ferrandi, Fabrizio},
title = {PandA-Bambu release notes},
url = {https://github.com/ferrandi/PandA-bambu/blob/c443bf14c33a9a74008ada12f56e7a62e30e5efe/NEWS#L304},
urldate = {2023-11-16},
year = {2014},
}

@article{crest,
  author       = {Andreas Tiemeyer and
                  Tom Melham and
                  Daniel Kroening and
                  John O'Leary},
  title        = {{CREST:} Hardware Formal Verification with {ANSI-C} Reference Specifications},
  journal      = {CoRR},
  volume       = {abs/1908.01324},
  year         = {2019},
  url          = {http://arxiv.org/abs/1908.01324},
  eprinttype    = {arXiv},
  eprint       = {1908.01324},
  timestamp    = {Fri, 09 Aug 2019 12:15:56 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1908-01324.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{dynamatic,
  author       = {Lana Josipovic and
                  Radhika Ghosal and
                  Paolo Ienne},
  editor       = {Jason Helge Anderson and
                  Kia Bazargan},
  title        = {Dynamically Scheduled High-level Synthesis},
  booktitle    = {Proceedings of the 2018 {ACM/SIGDA} International Symposium on Field-Programmable
                  Gate Arrays, {FPGA} 2018, Monterey, CA, USA, February 25-27, 2018},
  pages        = {127--136},
  publisher    = {{ACM}},
  year         = {2018},
  url          = {https://doi.org/10.1145/3174243.3174264},
  doi          = {10.1145/3174243.3174264},
  timestamp    = {Wed, 07 Dec 2022 23:11:53 +0100},
  biburl       = {https://dblp.org/rec/conf/fpga/JosipovicGI18.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@INPROCEEDINGS{ferrandi2021bambu,
  author={Ferrandi, Fabrizio and Castellana, Vito Giovanni 
          and Curzel, Serena and Fezzardi, Pietro and Fiorito, Michele 
          and Lattuada, Marco and Minutoli, Marco and Pilato, Christian 
          and Tumeo, Antonino},
  booktitle={2021 58th ACM/IEEE Design Automation Conference (DAC)}, 
  title={Bambu: an Open-Source Research Framework for the 
         High-Level Synthesis of Complex Applications}, 
  year={2021},
  pages={1327-1330},
  abstract = {This paper presents the open-source high-level synthesis (HLS) research 
              framework Bambu. Bambu provides a research environment to experiment with 
              new ideas across HLS, high-level verification and debugging, FPGA/ASIC design,
              design flow space exploration, and parallel hardware accelerator design. The 
              tool accepts as input standard C/C++ specifications and compiler intermediate 
              representations (IRs) coming from the well-known Clang/LLVM and GCC compilers. 
              The broad spectrum and flexibility of input formats allow the electronic 
              design automation (EDA) research community to explore and integrate new 
              transformations and optimizations. The easily extendable modular framework 
              already includes many optimizations and HLS benchmarks used to evaluate 
              the QoR of the tool against existing approaches [1]. The integration with 
              synthesis and verification backends (commercial and open-source) allows 
              researchers to quickly test any new finding and easily obtain performance 
              and resource usage metrics for a given application. Different FPGA devices 
              are supported from several different vendors: AMD/Xilinx, Intel/Altera, 
              Lattice Semiconductor, and NanoXplore. Finally, integration with the OpenRoad 
              open-source end-to-end silicon compiler perfectly fits with the recent push 
              towards open-source EDA.},
  publisher={{IEEE}},
  doi={10.1109/DAC18074.2021.9586110},
  ISSN={0738-100X},
  month={12},
  pdf={https://re.public.polimi.it/retrieve/668507/dac21_bambu.pdf}
}

@InProceedings{TanFeb15,
 author={Tan, Mingxing and Dai, Steve and Gupta, Udit and Zhang, Zhiru},
 title =	 {Mapping-aware constrained scheduling for {LUT-based FPGAs}},
 booktitle = {Proceedings of the 23rd {ACM}/{SIGDA} International
                  Symposium on Field Programmable Gate Arrays},
 year =	 2015,
 address =	 {Monterey, CA},
 month =	 feb,
 pages =	 {190--9}
}
@InProceedings{RizziJul23,
author={Rizzi, Carmine and Guerrieri, Andrea and Josipović, Lana},  
booktitle={Proceedings of the 60rd ACM/IEEE Design Automation Conference}, 
title={An Iterative Method for Mapping-Aware Frequency Regulation in Dataflow Circuits}, 
year={2023},
month=jul,
address ={San Francisco, CA},
 note =  {To appear.}}

@InProceedings{WangOct23,
author={Wang, Hanyu and Rizzi, Carmine and Josipović, Lana},  
booktitle={Proceedings of the 42nd IEEE/ACM Intl. Conference on Computer-Aided Design}, 
title={{MapBuf}: Simultaneous Technology Mapping and Buffer Insertion for {HLS} Performance Optimization}, 
year={2023},
month=oct,
address ={San Francisco, CA},
 note =  {To appear.}}

@InProceedings{UstunNov20,
 author={Ustun, Ecenur and Deng, Chenhui and Pal, Debjit and Li, Zhijing and Zhang, Zhiru},
 title =  {Accurate operation delay prediction for {FPGA HLS} using graph neural networks},
 booktitle = {Proceedings of the 39th International Conference on Computer-Aided Design},
 year =   2020,
 address =  {Virtual},
 month =  nov,
 pages={1--9},
}

@inproceedings{ZhengFeb14,
author = {Zheng, Hongbin and Gurumani, Swathi T. and Rupnow, Kyle and Chen, Deming},
title = {Fast and Effective Placement and Routing Directed High-Level Synthesis for {FPGA}s},
booktitle = {Proceedings of the 2014 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays},
pages = {1--10},
month =  feb,
address = {Monterey, CA},
year = 2014
}