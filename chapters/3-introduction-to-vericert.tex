\chapter{Introduction to Vericert}%
\label{sec:introduction-to-vericert}

\begin{quote}\itshape
  This chapter describes the main architecture of the HLS tool, and the way in
  which the Verilog back end was added to \compcert{}.  This chapter also covers
  an example of converting a simple C program into hardware, expressed in the
  Verilog language.
\end{quote}

\noindent Our solution to the verification problem in \gls{HLS} is Vericert, a
formally verified \gls{HLS} tool.  First, we will describe the main design
decisions behind Vericert in \cref{sec:itv:main-design-decisions} and we will
then give an example of a translation from C code into Verilog through Vericert
in \cref{sec:itv:translating-c-to-verilog}.

\section{Main Design Decisions}%
\label{sec:itv:main-design-decisions}

\paragraph{Choice of source language}
C was chosen as the source language as it remains the most common source
language amongst production-quality HLS tools~\cite{canis13_l,
  amd23_vitis_high_synth, intel20_hsc, pilato13_bambu}. This, in turn, may be
because it is \textquote[{\textcite{gajski10_what_hls}}]{[t]he starting point
  for the vast majority of algorithms to be implemented in hardware}, lending a
degree of practicality.  The availability of
\compcert{}~\cite{leroy09_formal_verif_realis_compil} also provides a solid
basis for formally verified C compilation.
%Since a lot of existing code for HLS is written in C, supporting C as an input language, rather than a custom domain-specific language, means that \vericert{} is more practical.
%An alternative was to support LLVM IR as an input language, however, to get a full work flow from a higher level language to hardware, a front end for that language to LLVM IR would also have to be verified. \JW{Maybe save LLVM for the `Choice of implementation language'?}
We considered Bluespec~\cite{nikhil04_bsv}, but decided that although it
\textquote[{\textcite{greaves19_resear_note}}]{can be classed as a high-level
  language}, it is too hardware-oriented to be suitable for traditional HLS.  We
also considered using a language with built-in parallel constructs that map well
to parallel hardware, such as occam~\cite{page91_compil_occam},
Spatial~\cite{koeplinger18_s} or Scala~\cite{bachrach12_chisel}.
% However, this would not qualify as being HLS due to the manual parallelism that would have to be performed. \JW{I don't think the presence of parallelism stops it being proper HLS.}
%\JP{I think I agree with Yann here, but it could be worded better. At any rate not many people have experience writing what is essentially syntactic sugar over a process calculus.}
%\JW{I mean: there are plenty of software languages that involve parallel constructs. Anyway, perhaps we can just dismiss occam for being too obscure.}


\paragraph{Choice of target language}
Verilog~\cite{06_ieee_stand_veril_hardw_descr_languag} is an \gls{HDL} that can
be synthesised into logic cells which can either be placed onto an \gls{FPGA} or
turned into an \gls{ASIC}.  Verilog was chosen as the output language for
\vericert{} because it is one of the most popular HDLs and there already exist a
few formal semantics for it that could be used as a
target~\cite{lööw19_verif_compil_verif_proces, meredith10_veril}.  Bluespec,
previously ruled out as a source language, is another possible target and there
exists a formally verified translation to circuits using
K\^{o}ika~\cite{bourgeat20_essen_blues}. %\JP{This needs an extra comment maybe?}\YH{Maybe about bluespec not being an ideal target language because it's quite high-level?} % but targeting this language would not be trivial as it is not meant to be targeted by an automatic tool, instead strives to a formally verified high-level hardware description language instead.

%\JW{Can we mention one or two alternatives that we considered? Bluespec or Chisel or one of Adam Chlipala's languages, perhaps?}

\paragraph{Choice of implementation language}
We chose Coq as the implementation language because of its mature support for
code extraction; that is, its ability to generate OCaml programs directly from
the definitions used in the theorems.  We note that other authors have had some
success reasoning about the HLS process using other theorem provers such as
Isabelle~\cite{ellis08_csicgfu}.
\compcert{}~\cite{leroy09_formal_verif_realis_compil} was chosen as the front
end because it has a well established framework for simulation proofs about
intermediate languages, and it already provides a validated C
parser~\cite{jourdan12_valid_lr_parser}.  The Vellvm
framework~\cite{zhao12_formal_llvm_inter_repres_verif_progr_trans} was also
considered because several existing HLS tools are already LLVM-based, but
additional work would be required to support a high-level language like C as
input.  The .NET framework has been used as a basis for other HLS tools, such as
Kiwi~\cite{greaves08_kiwi}, and LLHD~\cite{schuiki20_llhd} has been recently
proposed as an intermediate language for hardware design, but neither are
suitable for us because they lack formal semantics.

\begin{figure}
  \centering
  \begin{tikzpicture}
    [font=\strut\sffamily]
    \node[ir] (compcertc) {CompCert C};
    \node[right=2cm of compcertc] (frontend) {};
    \begin{pgfonlayer}{background}
          \node[bgbox,fill=bgbox1,minimum height=4cm,minimum width=3cm,yshift=3mm]
    (frontendbg) at (frontend) {};
    \end{pgfonlayer}
    \node[pass] (frontendpass) at (frontend) {$\vphantom{A}\cdots$};
    \node[right=3.5cm of frontend] (rtlghost) {};
    \begin{pgfonlayer}{background}
      \node[bgbox,fill=bgbox2,minimum height=4cm,minimum width=3cm,yshift=3mm]
      (rtlghostbg) at (rtlghost) {};
    \end{pgfonlayer}
    \node[ir,below=2mm of rtlghost,xshift=-8mm] (rtl) {\rtl{}};
    \node[pass,right=5mm of rtl] (rtlpass) {$\vphantom{A}\cdots$};
    \node[pass,above=2mm of rtlghost] (opts) {optimisations};
    \node[anchor=south,above=2mm of opts] (backend) {Back End};
    \node[ir,right=2cm of rtlghost] (nativecode) {Native Code};
    \path (backend) -| node {Front End} (frontend);
    \draw[ed] (compcertc) -- (frontendpass) -- ++(2cm,0) |- (rtl);
    \draw[ed] (rtl) -- (rtlpass) -- ++(1cm,0) |- (nativecode);
    \draw[very thick] (opts) to [out=310,in=20] (rtl);
    \draw[edr] (rtl) to [out=90,in=220] (opts);
    \node[pass,below=2.3cm of compcertc] (findbb) {find\\basic blocks};
    \node[ir,right=of findbb] (rtlblock) {\rtlblock{}};
    \draw[ed] (rtlblock) to [out=220,in=320,loop,looseness=7] (rtlblock);
    \node[pass,right=of rtlblock] (schedule) {schedule};
    \node[pass,below=of rtlblock] (ifconv) {if-conversion};
    \node[ir,right=of schedule] (rtlpar) {\rtlpar{}};
    \node[pass,below=of findbb,yshift=-2cm] (hyperblock destruction) {hyperblock\\destruction};
    \node[ir,right=of hyperblock destruction] (rtlsubpar) {\rtlsubpar{}};
    \node[pass,right=of rtlsubpar] (htl generation) {\htl{} \\
      generation};
    \node[ir,right=of htl generation] (htl) {\htl{}};
    \node[pass,right=of htl] (bram insertion) {BRAM \\ insertion};
    \node[ir,below=of bram insertion] (htlmem) {\htl{}};
    \node[pass,left=of htlmem] (forward substitution) {forward \\ substitution};
    \node[ir,left=of forward substitution] (htlsubst) {\htl{}};
    \node[pass,left=of htlsubst] (verilog generation) {verilog \\ generation};
    \node[ir,left=of verilog generation] (verilog) {Verilog};

    \begin{pgfonlayer}{background}
      \node[bgbox,fit={(findbb)(rtlblock)(ifconv)(rtlpar)}] (schedulebox) {};
      \node[bgbox,fit={(hyperblock destruction)(bram
        insertion)(htlmem)(forward substitution)(verilog)}] (hardwaregenbox) {};
    \end{pgfonlayer}

      \path (hardwaregenbox.north west) --
      node[font=\sffamily\small,align=center,rotate=90,yshift=5mm] (hardwaregen label)
      {Hardware Generation\\\Cref{sec:hardware-generation}}
      (hardwaregenbox.south west);
      \path (schedulebox.north west) --
      node[font=\sffamily\small,align=center,rotate=90,yshift=5mm] (schedule label)
      {Hyperblock Scheduling\\\Cref{sec:hyperblock-scheduling}}
      (schedulebox.south west);

      \begin{pgfonlayer}{background}
        \node[bgbox,fill=bgbox4,fit={(hyperblock destruction)(bram
          insertion)(htlmem)(forward substitution)(verilog)(hardwaregen label)}]
        (hardwaregenboxb) {};
      \node[bgbox,fill=bgbox3,fit={(findbb)(rtlblock)(ifconv)(rtlpar)(schedule
        label)}] (scheduleboxb) {};
      \filldraw[bgbox,fill=bgbox3] (scheduleboxb.north west) rectangle
      (hardwaregenboxb.north east
      |- scheduleboxb.south east);
      \end{pgfonlayer}

    \path (rtlghostbg.west) -| node[font=\sffamily\small,anchor=south,rotate=90] {CompCert} (hardwaregen label);

    \draw[ed] (rtl) -- ++(0,-1.3cm) -| (findbb) -- (rtlblock);
    \draw[ed] (rtlblock) -- (schedule) -- (rtlpar);
    \draw[ed] (rtlpar) -- ++(0,-2.7cm) -| (hyperblock destruction) -- (rtlsubpar);
    \draw[ed] (rtlsubpar) -- (htl generation) -- (htl);
    \draw[ed] (htl) -- (bram insertion) -- (htlmem);
    \draw[ed] (htlmem) -- (forward substitution) -- (htlsubst);
    \draw[ed] (htlsubst) -- (verilog generation) -- (verilog);
  \end{tikzpicture}
  \caption{\vericert{} as a Verilog back end to \compcert{}.}%
  \label{fig:rtlbranch}
\end{figure}

\paragraph{Architecture of \vericert{}}

An overview of \vericert{}'s workflow is given in \cref{fig:rtlbranch}, which
shows that \vericert{} branches off from \compcert{} at the \rtl{} stage,
followed by a number of transformations related to the scheduling instructions,
and finally transformations that generate the final hardware.

We select CompCert's register transfer language (\rtl{}) as the starting
point. Branching off \emph{before} this point (at CminorSel or earlier) denies
\compcert{} the opportunity to perform optimisations such as constant
propagation and dead-code elimination, which, despite being designed for
software compilers, have been found useful in HLS tools as
well~\cite{cong11_high_level_synth_fpgas}. And if we branch off \emph{after}
this point (at LTL or later) then \compcert{} has already performed register
allocation to reduce the number of registers and spill some variables to the
stack; this transformation is not required in HLS because there are many more
registers available, and these should be used instead of \gls{BRAM} whenever
possible.

\rtl{} is also attractive because it is the closest intermediate language to
LLVM \gls{IR}, which is used by several existing HLS compilers.  It has an
unlimited number of pseudo-registers, and is represented as a \gls{CFG} where
each instruction is a node with links to the instructions that can follow it.
\rtl{} does not have the SSA property, however, this is not required for the
translation to hardware and mainly assists the static analysis passes.  One
difference between LLVM \gls{IR} and \rtl{} is that \rtl{} includes operations
that are specific to the chosen target architecture; we chose to target the
x86\_32 back end because it generally produces relatively dense \rtl{} thanks to
the availability of complex addressing modes.

From the \rtl{} representation, Vericert first generates a hyperblock
representation called \rtlblock{} by first generating basic blocks and then
performing general if-conversion to combine blocks.  The hyperblock is
represented as a basic block of predicated instructions with an exit instruction
to leave the basic block prematurely.  This hyperblock is then scheduled and
transformed into \rtlpar{}, which places each instruction into a specific state.
The scheduling process is described in detail in
\cref{sec:hyperblock-scheduling}.

Next, the hyperblocks are destroyed again to explicitly place instructions into
individual states.  Next, \htl{} is generated, which is a language that models
an \gls{FSMD}.  A few low-level and hardware specific optimisations are
performed at this level, including \gls{BRAM} insertion, which generates a
proper memory interface for any interaction with the stack, and forward
substitution, which ensures that the writes to registers are parallelised by
transforming blocking assignment into nonblocking assignment.  Finally,
syntactic Verilog is generated from \htl{}, which consists of translating the
\gls{FSMD} into a case statement and implementing the memory interface in
Verilog.

\begin{figure}
  \centering
    \begin{subfigure}[b]{0.48\linewidth}
\begin{minted}[fontsize=\footnotesize,linenos,xleftmargin=20pt]{c}
int main() {
    int x[2] = {3, 6};
    int i = 1;
    return x[i];
}
\end{minted}
      \caption{Example C code passed to \vericert{}.}\label{fig:accumulator_c}
    \end{subfigure}\hfill%
    \begin{subfigure}[b]{0.48\linewidth}
\begin{minted}[fontsize=\footnotesize,linenos,xleftmargin=20pt]{c}
main() {
    9:  x5 = 3
    8:  int32[stack(0)] = x5
    7:  x4 = 6
    6:  int32[stack(4)] = x4
    5:  x1 = 1
    4:  x3 = stack(0) (int)
    3:  x2 = int32[x3 + x1 * 4 + 0]
        goto 1
    2:  x2 = 0
    1:  return x2
}
\end{minted}
      \caption{\rtl{} produced by the \compcert{} front end without any optimisations.}\label{fig:accumulator_rtl}
    \end{subfigure}
    \caption{Translating a simple program from C to \rtl{}.}\label{fig:accumulator_c_rtl}
\end{figure}

\begin{figure}
  \centering
  \inputminted[fontsize=\footnotesize,linenos,xleftmargin=20pt]{systemverilog}{figures/3-introduction-to-vericert/translated-verilog.sv}
  \caption{Verilog implementation of \rtl{} code produced by CompCert produced
    by scheduling the code, instantiating a BRAM and translating to Verilog.}
  \label{fig:accumulator:verilog-implementation}
\end{figure}

\section{Translating C to Verilog by Example}%
\label{sec:itv:translating-c-to-verilog}

\Cref{fig:accumulator_c_rtl} illustrates the translation of a simple program
that stores and retrieves values from an array.  In this section, we describe
the stages of the \vericert{} translation, referring to this program as an
example.

\subsection{Translating C to \rtl{}}

The first stage of the translation uses unmodified \compcert{} to transform the
C input, shown in \cref{fig:accumulator_c}, into a \rtl{} intermediate
representation, shown in \cref{fig:accumulator_rtl}.  As part of this
translation, function inlining is performed on all functions, which allows us to
support function calls without having to support the \texttt{Icall} \rtl{}
instruction.  Although the duplication of the function bodies caused by inlining
can increase the area of the hardware, it can have a positive effect on latency
and is therefore a common HLS optimisation~\cite{noronha17_rapid_fpga}. Inlining
precludes support for recursive function calls, but this feature is not
supported in most HLS tools anyway~\cite{thomas16_srcht}.

%\JW{Is that definitely true? Was discussing this with Nadesh and George recently, and I ended up not being so sure. Inlining could actually lead to \emph{reduced} resource usage because once everything has been inlined, the (big) scheduling problem could then be solved quite optimally. Certainly inlining is known to increase register pressure, but that's not really an issue here. If we're  not sure, we could just say that inlining everything leads to bloated Verilog files and the inability to support recursion, and leave it at that.}\YH{I think that is true, just because we don't do scheduling.  With scheduling I think that's true, inlining actually becomes quite good.}

\subsection{Translating \rtl{} to \htl{}}

%   + TODO Explain the main mapping in a short simple way

%   + TODO Clarify connection between CFG and FSMD

%   + TODO Explain how memory is mapped
%\JW{I feel like this could use some sort of citation, but I'm not sure what. I guess this is all from "Hardware Design 101", right?}\YH{I think I found a good one actually, which goes over the basics.}
%\JW{I think it would be worth having a sentence to explain how the C model of memory is translated to a hardware-centric model of memory. For instance, in C we have global variables/arrays, stack-allocated variables/arrays, and heap-allocated variables/arrays (anything else?). In Verilog we have registers and \gls{BRAM} blocks. So what's the correspondence between the two worlds? Globals and heap-allocated are not handled, stack-allocated variables become registers, and stack-allocated arrays become \gls{BRAM} blocks? Am I close?}\YH{Stack allocated variables become \gls{BRAM} as well, so that we can deal with addresses easily and take addresses of any variable.} \JW{I see, thanks. So, in short, the only registers in your hardware designs are those that store things like the current state, etc. You generate a fixed number of registers every time you synthesis -- you don't generate extra registers to store any of the program variables. Right?}

The next translation is from \rtl{} to a new hardware translation language
(\htl{}). %, which is one step towards being completely translated to hardware described in Verilog.
This involves going from a CFG representation of the computation to a \gls{FSMD}
representation~\cite{hwang99_ffplp}. The core idea of the FSMD representation is
that it separates the control flow from the operations on the memory and
registers. %\JP{I've become less comfortable with this term, but it's personal preference so feel free to ignore. I think `generalised finite state machine' (i.e.\ thinking of the entire `data-path' as contributing to the overall state) is more accurate.}\YH{Hmm, yes, I mainly chose FSMD because there is quite a lot of literature around it.  I think for now I'll keep it but for the final draft we could maybe change it.}
%This means that the state transitions can be translated into a simple finite state machine (FSM) where each state contains data operations that update the memory and registers.
Hence, an \htl{} program consists of two maps from states to Verilog statements:
the \emph{\gls{control logic}} map, which expresses state transitions, and the
\emph{\gls{data path}} map, which expresses computations.
\Cref{fig:accumulator_diagram} shows the resulting \gls{FSMD} architecture. The
right-hand block is the control logic that computes the next state, while the
left-hand block updates all the registers and \gls{BRAM} based on the current
program state.

The \htl{} language was mainly introduced to simplify the proof of translation
from \rtl{} to Verilog, as these languages have very different semantics.  It
serves as an intermediate language with similar semantics to \rtl{} at the top
level, using maps to represents what to execute at every state, and similar
semantics to Verilog at the lower level by already using Verilog statements
instead of more abstract instructions.  Compared to plain Verilog, \htl{} is
simpler to manipulate and analyse, thereby making it easier to prove
optimisations like proper \gls{BRAM} insertion.

\begin{figure*}
  \centering
\definecolor{control}{HTML}{b3e2cd}
\definecolor{data}{HTML}{fdcdac}
\begin{tikzpicture}
  \begin{scope}[scale=1.3]
  \fill[control,fill opacity=1] (6.5,0) rectangle (12,5);
  \fill[data,fill opacity=1] (0,0) rectangle (5.5,5);
  \shade[left color=data, right color=control] (6.7,0) rectangle (5.3,5);
  \node[anchor=north west,font=\bfseries\sffamily] at (0.2,4.9) {Data Path};
  \node[anchor=north west,font=\bfseries\sffamily] at (6.9,4.9) {Control Logic};

  \filldraw[fill=white,rounded corners=3pt] (7,0.5) rectangle (11.5,2.2);
  \node at (8.2,2) {\footnotesize \texttt{Next State FSM}};
  \begin{scope}[xshift=5mm,yshift=-1mm]
  \foreach \x in {8,...,3}
    {\pgfmathtruncatemacro{\y}{8-\x}%
      \node[draw,circle,inner sep=0,minimum size=10,scale=0.8] (s\x) at
      (7.5+\y/2,1.35) {};}
  \node[font=\tiny] at (s8) {8};
  \node[font=\tiny] at (s7) {14};
  \node[font=\tiny] at (s6) {15};
  \node[font=\tiny] at (s5) {16};
  \node[font=\tiny] at (s4) {18};
  \node[font=\tiny] (s1c) at (s3) {17};
  \node[draw,circle,inner sep=0,minimum size=13,scale=0.8] (s1) at (s1c) {};
  \draw[-{Latex[length=1mm,width=0.7mm]}] (s1) to [loop,looseness=5,out=45,in=-45] (s1);
  \foreach \x in {8,...,4}
    {\pgfmathtruncatemacro{\y}{\x-1}\draw[-{Latex[length=1mm,width=0.7mm]}] (s\x) -- (s\y);}
  \draw[-{Latex[length=1mm,width=0.7mm]}] (7.2,1.7) to [out=0,in=100] (s8);
  \end{scope}

  \node[draw,fill=white] (nextstate) at (9.25,3) {\tiny \texttt{current state}};
  \draw[-{Latex[length=1mm,width=0.7mm]}] let \p1 = (nextstate) in
    (11.5,1.25) -| (11.75,\y1) -- (nextstate);
  \draw let \p1 = (nextstate) in (nextstate) -- (6,\y1) |- (6,1.5);
  \node[scale=0.5,rotate=60] at (7.5,0.75) {\texttt{clk}};
  \node[scale=0.5,rotate=60] at (7.7,0.82) {\texttt{reset}};
  \draw[-{Latex[length=1mm,width=0.7mm]}] (7.65,-0.5) -- (7.65,0.5);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (7.45,-0.5) -- (7.45,0.5);

  \filldraw[fill=white,rounded corners=3pt] (2,0.5) rectangle (5,3);
  \filldraw[fill=white] (0.25,0.5) rectangle (1.5,2.75);
  \node at (2.6,2.8) {\footnotesize \texttt{Update}};
  \node[align=center] at (0.875,2.55) {\footnotesize \texttt{\gls{BRAM}}};
  \node[scale=0.5] at (4.7,1.5) {\texttt{state}};
  \draw[-{Latex[length=1mm,width=0.7mm]}] (6,1.5) -- (5,1.5);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (6,1.5) -- (7,1.5);
  \node[scale=0.5,rotate=60] at (4.1,0.9) {\texttt{finished}};
  \node[scale=0.5,rotate=60] at (3.9,0.95) {\texttt{return\_val}};
  \node[scale=0.5,rotate=60] at (2.5,0.75) {\texttt{clk}};
  \node[scale=0.5,rotate=60] at (2.7,0.82) {\texttt{reset}};

  \node[scale=0.5,right,inner sep=5pt] (ram1) at (2,2.1) {\texttt{u\_en}};
  \node[scale=0.5,right,inner sep=5pt] (ram2) at (2,1.9) {\texttt{wr\_en}};
  \node[scale=0.5,right,inner sep=5pt] (ram3) at (2,1.7) {\texttt{addr}};
  \node[scale=0.5,right,inner sep=5pt] (ram4) at (2,1.5) {\texttt{d\_in}};
  \node[scale=0.5,right,inner sep=5pt] (ram5) at (2,1.3) {\texttt{d\_out}};

  \node[scale=0.5,left,inner sep=5pt] (r1) at (1.5,2.1) {\texttt{u\_en}};
  \node[scale=0.5,left,inner sep=5pt] (r2) at (1.5,1.9) {\texttt{wr\_en}};
  \node[scale=0.5,left,inner sep=5pt] (r3) at (1.5,1.7) {\texttt{addr}};
  \node[scale=0.5,left,inner sep=5pt] (r4) at (1.5,1.5) {\texttt{d\_in}};
  \node[scale=0.5,left,inner sep=5pt] (r5) at (1.5,1.3) {\texttt{d\_out}};

  \draw[-{Latex[length=1mm,width=0.7mm]}] (ram1) -- (r1);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (ram2) -- (r2);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (ram3) -- (r3);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (ram4) -- (r4);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (r5) -- (ram5);

  \draw[-{Latex[length=1mm,width=0.7mm]}] (4,0.5) -- (4,-0.5);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (3.75,0.5) -- (3.75,-0.5);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (2.45,-0.5) -- (2.45,0.5);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (2.65,-0.5) -- (2.65,0.5);

  \foreach \x in {0,...,1}
  {\draw (0.25,1-0.25*\x) -- (1.5,1-0.25*\x); \node at (0.875,0.88-0.25*\x) {\tiny \x};}

  %\node[scale=0.5] at (1.2,2.2) {\texttt{wr\_en}};
  %\node[scale=0.5] at (1.2,2) {\texttt{wr\_addr}};
  %\node[scale=0.5] at (1.2,1.8) {\texttt{wr\_data}};
  %\node[scale=0.5] at (1.2,1.4) {\texttt{r\_addr}};
  %\node[scale=0.5] at (1.2,1.2) {\texttt{r\_data}};
  %
  %\node[scale=0.5] at (2.3,2.2) {\texttt{wr\_en}};
  %\node[scale=0.5] at (2.3,2) {\texttt{wr\_addr}};
  %\node[scale=0.5] at (2.3,1.8) {\texttt{wr\_data}};
  %\node[scale=0.5] at (2.3,1.4) {\texttt{r\_addr}};
  %\node[scale=0.5] at (2.3,1.2) {\texttt{r\_data}};
  %
  %\draw[-{Latex[length=1mm,width=0.7mm]}] (2,2.2) -- (1.5,2.2);
  %\draw[-{Latex[length=1mm,width=0.7mm]}] (2,2) -- (1.5,2);
  %\draw[-{Latex[length=1mm,width=0.7mm]}] (2,1.8) -- (1.5,1.8);
  %\draw[-{Latex[length=1mm,width=0.7mm]}] (2,1.4) -- (1.5,1.4);
  %\draw[-{Latex[length=1mm,width=0.7mm]}] (1.5,1.2) -- (2,1.2);

  \filldraw[fill=white] (2.8,3.25) rectangle (4.2,4.75);
  \node at (3.5,4.55) {\footnotesize \texttt{Registers}};
  \draw[-{Latex[length=1mm,width=0.7mm]}] (2,2.4) -| (1.75,4) -- (2.8,4);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (4.2,4) -- (5.25,4) |- (5,2.4);
  \draw[-{Latex[length=1mm,width=0.7mm]}] (5.25,2.4) -- (5.9,2.4) arc (180:0:.1)
  -- (6.2,2.4) |- (7,1.8);

  \node[scale=0.5] at (3.5,4.2) {\texttt{reg\_2}};
  \node[scale=0.5] at (3.5,4) {\texttt{reg\_4}};
  \node[scale=0.5] at (3.5,3.8) {\texttt{reg\_6}};
  \node[scale=0.5] at (3.5,3.6) {\texttt{reg\_8}};
  \node[scale=0.5] at (3.5,3.4) {\texttt{reg\_10}};
\end{scope}
\end{tikzpicture}
%  \alt{Diagram displaying the data-path and its internal modules, as well as the control logic and its state machine.}
\caption{The FSMD for the example shown in \cref{fig:accumulator_c_rtl}, split
  into a data path and control logic for the next state calculation.  The update
  block takes the current state, current values of all registers and at most one
  value stored in the \gls{BRAM}, and calculates a new value that can either be
  stored back in the \gls{BRAM} or in a
  register.}\label{fig:accumulator_diagram}
\end{figure*}

%\JP{Does it? Verilog has neither physical registers nor RAMs, just language constructs which the synthesiser might implement with registers and RAMs. We should be clear whether we're talking about the HDL representation, or the synthesised result: in our case these can be very different since we don't target any specific architectural features of an FPGA fabric of ASIC process.}
\paragraph{Translating memory}
Typically, HLS-generated hardware consists of a sea of registers and RAMs.  This
memory view is very different from the C memory model, so we perform the
following translation from \compcert{}'s abstract memory model to a concrete
\gls{BRAM}.\@ Variables that do not have their address taken are kept in
registers, which correspond to the registers in \rtl{}.  All address-taken
variables, arrays, and structs are kept in \gls{BRAM}.  The stack of the main
function becomes an unpacked array of 32-bit integers representing the
\gls{BRAM} block.  Any loads and stores are temporarily translated to direct
accesses to this array, where each address has its offset removed and is divided
by four.  In a separate \htl{}-to-\htl{} conversion, these direct accesses are then
translated to proper loads and stores that use a \gls{BRAM} interface to
communicate with the \gls{BRAM}, shown on lines 21, 24 and 28 of
\cref{fig:accumulator_v}.  This pass inserts a \gls{BRAM} block with the
interface around the unpacked array.  Without this interface and without the
\gls{BRAM} block, the synthesis tool processing the Verilog hardware description
would not identify the array as a \gls{BRAM}, and would instead implement it
using many registers.  This interface is shown on lines 9--15 in the Verilog
code in \cref{fig:accumulator_v}.  A high-level overview of the architecture and
of the \gls{BRAM} interface can be seen in \cref{fig:accumulator_diagram}.

\paragraph{Translating instructions}

Most \rtl{} instructions correspond to hardware constructs.
%Each \rtl{} instruction either corresponds to a hardware construct or does not have to be handled by the translation, such as function calls (because of inlining). \JW{Are function calls the only \rtl{} instruction that we ignore? (And I guess return statements too for the same reason.)}\YH{Actually, return instructions are translated (because you can return from main whenever), so call instructions (Icall, Ibuiltin and Itailcall) are the only functions that are not handled.}
% JW: Thanks; please check proposed new text.
For example, line 2 in \cref{fig:accumulator_rtl} shows a 32-bit register
\texttt{x5} being initialised to 3, after which the control flow moves execution
to line 3. This initialisation is also encoded in the Verilog generated from \htl{}
at state 8 in both the control logic and data-path always-blocks, shown at lines
33 and 16 respectively in \cref{fig:accumulator_v}.  Simple operator
instructions are translated in a similar way.  For example, the add instruction
is just translated to the built-in add operator, similarly for the multiply
operator.  All 32-bit instructions can be translated in this way, but some
special instructions require extra care. One such instruction is the
\texttt{Oshrximm} instruction, which is discussed further in
\cref{sec:algorithm:optimisation:oshrximm}. Another is the
\texttt{Oshldimm} instruction, which is a left rotate instruction that has no
Verilog equivalent and therefore has to be implemented in terms of other
operations and proven to be equivalent.
% In addition to any non-32-bit operations, the remaining
The only 32-bit instructions that we do not translate are case-statements
(\texttt{Ijumptable}) and those instructions related to function calls
(\texttt{Icall}, \texttt{Ibuiltin}, and \texttt{Itailcall}), because we enable
inlining by default.

\subsection{Translating \htl{} to Verilog}

Finally, we have to translate the \htl{} code into proper
Verilog. % and prove that it behaves the same as the \rtl{} according to the Verilog semantics.
The challenge here is to translate our FSMD representation into a Verilog AST.
However, as all the instructions in \htl{} are already expressed as Verilog
statements, only the top-level data-path and control logic maps need to be
translated to valid Verilog case-statements.  We also require declarations for
all the variables in the program, as well as declarations of the inputs and
outputs to the module, so that the module can be used inside a larger hardware
design.  In addition to translating the maps of Verilog statements, an
always-block that will behave like the \gls{BRAM} also has to be created, which
is only modelled abstractly at the \htl{} level.  \Cref{fig:accumulator_v} shows
the final Verilog output that is generated for our example.

Although this translation seems quite straight\-forward, proving that this
translation is correct is complex.  All the implicit assumptions that were made
in \htl{} need to be translated explicitly to Verilog statements and it needs to
be shown that these explicit behaviours are equivalent to the assumptions made
in the \htl{} semantics.  One main example of this is proving that the
specification of the \gls{BRAM} in \htl{} does indeed behave in the same as its
Verilog implementation.  We discuss these proofs in upcoming sections.

% In general, the generated Verilog structure has similar to that of the \htl{}
% code.  The key difference is that the control and datapath maps become Verilog
% case-statements.  Other additions are the initialisation of all the variables
% in the code to the correct bitwidths and the declaration of the inputs and
% outputs to the module, so that the module can be used inside a larger hardware
% design.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% TeX-engine: luatex
%%% End:
